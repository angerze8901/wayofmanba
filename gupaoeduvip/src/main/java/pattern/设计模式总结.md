1. 单例模式(singleton)
在任何情况下,单例类永远只有一个实例存在,
穷举法:分为5种饿汉式,懒汉式,,双重检查锁(线程安全),内部静态类,枚举类,注册式单例
2. 原型模式(prototype)
从父类克隆一个相同的类,暂且称之为克类,java中定义所要克隆的父类须implments Cloneable
穷举法:登录的controller类,使用标签@prototype
3. 代理模式(proxy)
为其它对象提供一种代理以控制对这个对象的访问,在某些情况下,一个对象不适合或者不能直接引用另外一个对象,而代理对象可以在客户对象和目标对象之间起到中介的作用.
穷举法:
分为静态代理和动态代理(cglib和jdk),静态代理更像是对原有的类的拓展,不改变原有类的情况下,引入原有类,添加其他的操作方法
4. 策略模式(strategy)
将一个个算法封装起来,并且可以使他们相互切换
穷举法:
诸葛亮的锦囊妙计,每个锦囊就是一个策略;支付方式选择,每种支付方式就是一个策略;
5. 模板模式(template)
一个抽象类公开定义了执行他的方法的方式/模板.他的子类可以按需要重写方法实现,但是调用将以抽象类中定义的方式进行.属于行为型模式.
穷举法:
西游中的81难,这是一个顶层逻辑骨架;比如开启事务,获取session,关闭session,这些封装好的方法,内部就是一个定义好的模板;再比如淘宝的下单流程,登陆淘宝->选择商品->提交订单->付款.总体就是一个模板模式,具体的实现由子类实现.
6. 委派模式(delegate)
自己理解:就是全权托管给某个对象去执行交代的事情,不同于代理模式,代理模式只是代理去做某一部分,最终决定权还是在父类(被代理的对象),代理类并没有权利.
官方解释:有两个对象参与处理一个请求,接受请求的的对象将请求委托给另外一个去处理
穷举法:dispatchServlet,替身演员,项目经理
延伸-双亲委派机制
某个特定的类加载器在接到加载类的请求时,首先将加载任务委托给父类加载器,依次递归,如果父类加载器可以完成加载任务,就成功返回;只有父类加载器无法完成此家在任务时,才自己去加载.
[需结合jvm的类加载的方式研究](https://blog.csdn.net/zhaoenweiex/article/details/63289374)
7. 适配器模式(adapt)
自己理解:也可以理解成桥梁模式,某个功能有好几个步骤,如果是放在一个类中实现,复用率很低,耦合度很高,适配器就可以起到解耦的功能,将功能分成一个个类,然后在通过适配器组合实现该功能,同时不同的适配器可以是不同的组合实现
官方解释:作为两个不兼容的接口之间的桥梁,这种模式属于结构型模式
穷举法:电源适配器
8. 装饰者模式(decorator)
自己理解:在原有类的基础上,添加额外的功能,同时不破坏原有的类,然后再次封装成一个新的类
官方解释:允许向一个现有的对象添加新的功能,同时又不改变其结构,这种模式属于结构型模式
穷举法:
io读取
9. 观察者模式(observer)
自己理解:如果一个类被其他类当成观察的对象,这个对象只要有所改变,其他类也会随之响应
官方解释:当对象间存在一对多关系时,使用该模式.也就是当一个对象被修改时,则会自动通知他的依赖对象,这种模式属于行为型模式.
穷举法:
某东上产品的订阅功能
